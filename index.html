<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LiDAR TAS 실험 — LAN9662 802.1Qbv</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root {
  --bg: #0a0e17;
  --card: #131a2b;
  --border: #1e2a42;
  --text: #c8d6e5;
  --text2: #8899aa;
  --accent: #00d2ff;
  --accent2: #7c5cfc;
  --green: #00e676;
  --red: #ff5252;
  --orange: #ffab40;
  --yellow: #ffd740;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
}
.container { max-width: 1200px; margin: 0 auto; padding: 20px; }
h1 {
  text-align: center;
  font-size: 1.8em;
  margin: 30px 0 10px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.subtitle {
  text-align: center;
  color: var(--text2);
  margin-bottom: 30px;
  font-size: 0.95em;
}
.grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
}
.card h2 {
  font-size: 1.1em;
  margin-bottom: 15px;
  color: var(--accent);
}
.card.full { grid-column: 1 / -1; }
.setup-diagram {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
  padding: 20px;
  font-size: 0.9em;
}
.setup-box {
  padding: 12px 18px;
  border-radius: 8px;
  text-align: center;
  min-width: 120px;
}
.setup-box.lidar { background: #1a3a2a; border: 1px solid var(--green); }
.setup-box.switch { background: #2a1a3a; border: 1px solid var(--accent2); }
.setup-box.pc { background: #1a2a3a; border: 1px solid var(--accent); }
.setup-arrow { color: var(--text2); font-size: 1.2em; }
.setup-label { font-size: 0.75em; color: var(--text2); margin-top: 4px; }
.spec-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85em;
}
.spec-table th, .spec-table td {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  text-align: left;
}
.spec-table th { color: var(--accent); font-weight: 600; }
.spec-table td:nth-child(2) { color: var(--yellow); font-family: monospace; }

/* Result table */
.result-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.82em;
  font-family: 'SF Mono', 'Fira Code', monospace;
}
.result-table th {
  padding: 8px 6px;
  border-bottom: 2px solid var(--accent);
  text-align: right;
  color: var(--accent);
  font-weight: 600;
  white-space: nowrap;
}
.result-table th:first-child { text-align: left; }
.result-table td {
  padding: 6px 6px;
  border-bottom: 1px solid var(--border);
  text-align: right;
}
.result-table td:first-child { text-align: left; color: var(--text); }
.result-table tr:hover { background: rgba(0,210,255,0.05); }
.result-table .baseline { background: rgba(0,230,118,0.08); }
.result-table .loss { color: var(--red); font-weight: bold; }

/* Charts */
svg { width: 100%; overflow: visible; }
.axis text { fill: var(--text2); font-size: 11px; }
.axis line, .axis path { stroke: var(--border); }
.grid-line { stroke: var(--border); stroke-dasharray: 3,3; opacity: 0.5; }
.tooltip {
  position: absolute;
  background: rgba(19,26,43,0.95);
  border: 1px solid var(--accent);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 0.8em;
  pointer-events: none;
  z-index: 100;
  color: var(--text);
}

/* Key finding badges */
.findings {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  margin-bottom: 20px;
}
.finding {
  flex: 1;
  min-width: 150px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 15px;
  text-align: center;
}
.finding .value {
  font-size: 2em;
  font-weight: 700;
  font-family: monospace;
}
.finding .label {
  font-size: 0.8em;
  color: var(--text2);
  margin-top: 4px;
}
.finding.green .value { color: var(--green); }
.finding.red .value { color: var(--red); }
.finding.orange .value { color: var(--orange); }
.finding.blue .value { color: var(--accent); }
.finding.purple .value { color: var(--accent2); }

.note {
  background: rgba(0,210,255,0.08);
  border-left: 3px solid var(--accent);
  padding: 10px 15px;
  margin-top: 15px;
  font-size: 0.85em;
  border-radius: 0 6px 6px 0;
}

/* Section divider */
.section-divider {
  text-align: center;
  margin: 50px 0 30px;
  padding: 15px;
  border-top: 2px solid var(--border);
  border-bottom: 2px solid var(--border);
}
.section-divider h1 {
  margin: 0;
  font-size: 1.6em;
}
.section-divider .sub {
  color: var(--text2);
  font-size: 0.9em;
  margin-top: 5px;
}

/* Heatmap */
.heatmap-cell {
  stroke: var(--bg);
  stroke-width: 2;
}

/* Gate Gantt */
.gate-gantt { margin: 10px 0; }
.gate-gantt .open { fill: var(--green); opacity: 0.7; }
.gate-gantt .close { fill: var(--red); opacity: 0.5; }

/* Guidelines */
.guideline-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-top: 15px;
}
.guideline-box {
  padding: 15px;
  border-radius: 8px;
  font-size: 0.85em;
}
.guideline-box.do {
  background: rgba(0,230,118,0.08);
  border: 1px solid rgba(0,230,118,0.3);
}
.guideline-box.dont {
  background: rgba(255,82,82,0.08);
  border: 1px solid rgba(255,82,82,0.3);
}
.guideline-box h3 {
  margin-bottom: 10px;
  font-size: 1em;
}
.guideline-box ul {
  padding-left: 18px;
  line-height: 1.8;
}
</style>
</head>
<body>
<div class="container">

<h1>LiDAR TAS 실험 결과</h1>
<p class="subtitle">IEEE 802.1Qbv Time-Aware Shaper — Ouster OS-1-16 + Microchip LAN9662</p>

<!-- Key Findings -->
<div class="findings">
  <div class="finding green">
    <div class="value">12/13</div>
    <div class="label">패킷 손실 없음<br>(스위치 버퍼링)</div>
  </div>
  <div class="finding red">
    <div class="value">51.6%</div>
    <div class="label">50ms/20% open<br>최악 Completeness</div>
  </div>
  <div class="finding orange">
    <div class="value">68.9%</div>
    <div class="label">최대 Burst 비율<br>(5ms / 20% open)</div>
  </div>
  <div class="finding blue">
    <div class="value">41ms</div>
    <div class="label">최대 Inter-Packet Gap<br>(50ms / 20% open)</div>
  </div>
</div>

<!-- Setup Diagram -->
<div class="card full">
  <h2>실험 구성</h2>
  <div class="setup-diagram">
    <div class="setup-box lidar">
      <div><strong>Ouster OS-1-16</strong></div>
      <div class="setup-label">192.168.6.11<br>UDP 7502<br>10Hz / 128 pkts/frame</div>
    </div>
    <div class="setup-arrow">&rarr; Ethernet &rarr;</div>
    <div class="setup-box switch">
      <div><strong>LAN9662</strong></div>
      <div class="setup-label">Port 2 (ingress)<br>802.1Qbv TAS<br>Port 1 (egress)</div>
    </div>
    <div class="setup-arrow">&rarr; Ethernet &rarr;</div>
    <div class="setup-box pc">
      <div><strong>PC</strong></div>
      <div class="setup-label">192.168.6.1<br>USB Ethernet<br>Python UDP socket</div>
    </div>
  </div>
  <div class="note">
    TAS는 Port 1 (egress)에 적용. Gate close 시 스위치가 패킷을 내부 버퍼에 저장하고,
    gate open 시 일괄 방출(burst). 버퍼 초과 시 패킷 드롭 발생.
  </div>
</div>

<div class="grid">
  <!-- LiDAR Spec -->
  <div class="card">
    <h2>LiDAR 스펙</h2>
    <table class="spec-table">
      <tr><td>모델</td><td>Ouster OS-1-16-A0</td></tr>
      <tr><td>해상도</td><td>2048 &times; 16</td></tr>
      <tr><td>회전 속도</td><td>10 Hz</td></tr>
      <tr><td>패킷/프레임</td><td>128 (16 cols/pkt)</td></tr>
      <tr><td>패킷 크기</td><td>3,328 bytes</td></tr>
      <tr><td>패킷 간격</td><td>~781 &micro;s</td></tr>
      <tr><td>데이터 레이트</td><td>~34 Mbps</td></tr>
      <tr><td>전송 시간/pkt</td><td>~26.6 &micro;s @1Gbps</td></tr>
    </table>
  </div>

  <!-- Switch Spec -->
  <div class="card">
    <h2>스위치 스펙</h2>
    <table class="spec-table">
      <tr><td>모델</td><td>Microchip LAN9662</td></tr>
      <tr><td>펌웨어</td><td>VelocitySP v2025.06</td></tr>
      <tr><td>포트</td><td>2&times; 1Gbps</td></tr>
      <tr><td>TAS 표준</td><td>IEEE 802.1Qbv</td></tr>
      <tr><td>최대 GCL 항목</td><td>8</td></tr>
      <tr><td>트래픽 클래스</td><td>8 (TC0~TC7)</td></tr>
      <tr><td>Tick Granularity</td><td>60 ns</td></tr>
      <tr><td>설정 도구</td><td>keti-tsn-cli (CoAP/MUP1)</td></tr>
    </table>
  </div>
</div>

<!-- Result Table -->
<div class="card full">
  <h2>측정 결과 (5초 측정 / 설정별)</h2>
  <table class="result-table" id="resultTable"></table>
</div>

<!-- Chart: Completeness -->
<div class="card full">
  <h2>Completeness vs Gate Schedule</h2>
  <svg id="chartComplete" height="300"></svg>
</div>

<!-- Chart: Jitter -->
<div class="card full">
  <h2>Jitter (Gap StdDev) vs Gate Schedule</h2>
  <svg id="chartJitter" height="300"></svg>
</div>

<!-- Chart: Burst -->
<div class="card full">
  <h2>Burst Rate vs Gate Schedule</h2>
  <svg id="chartBurst" height="300"></svg>
</div>

<!-- Chart: Max Gap -->
<div class="card full">
  <h2>Max Inter-Packet Gap vs Gate Schedule</h2>
  <svg id="chartMaxGap" height="300"></svg>
</div>

<!-- Analysis -->
<div class="card full">
  <h2>분석</h2>
  <div style="font-size:0.9em; line-height:1.8;">
    <p><strong>1. 스위치 버퍼링 효과</strong><br>
    13개 설정 중 12개에서 100% 패킷 수신. LAN9662는 gate close 동안 패킷을 내부 큐에 버퍼링하고,
    gate open 시 line rate로 burst 방출. 짧은 close 구간에서는 1~2개 패킷만 버퍼에 쌓이므로 손실 없음.</p>

    <p style="margin-top:10px;"><strong>2. 패킷 손실 조건</strong><br>
    유일한 손실: <strong>50ms / 20% open</strong> (51.6%). 40ms close 동안 ~51개 패킷이 버퍼에 도착하나,
    10ms open 동안 최대 ~376개 전송 가능 (1Gbps). 따라서 전송 대역폭이 아닌
    <strong>스위치 내부 버퍼 크기가 병목</strong>. LAN9662의 TC0 큐 버퍼가 ~30~40 패킷 수준으로 추정.</p>

    <p style="margin-top:10px;"><strong>3. Burst 패턴</strong><br>
    Close 구간이 길수록 burst 비율 증가: 0.1% (baseline) &rarr; 68.9% (5ms/20%).
    Burst 패킷은 &lt; 50&micro;s 간격으로 연속 도착하며, 이는 line rate 전송을 의미.
    수신측 어플리케이션의 버퍼 설계 시 고려 필요.</p>

    <p style="margin-top:10px;"><strong>4. 특이 패턴: Cycle-LiDAR 동기화</strong><br>
    일부 설정에서 예상보다 낮은 jitter 관찰 (예: 10ms/20% = 158&micro;s, 50ms/50% = 171&micro;s).
    이는 TAS cycle과 LiDAR 패킷 간격(781&micro;s)이 정수배 관계에 가까울 때 발생하는
    <strong>beat frequency 동기화</strong> 효과로, 대부분의 gate-open 구간에 패킷이 정확히 맞아떨어짐.</p>

    <p style="margin-top:10px;"><strong>5. 실무 시사점</strong><br>
    LiDAR + TSN 환경에서 TAS를 적용할 때, LiDAR 트래픽 클래스에 충분한 open 비율(&ge;50%)을
    할당하면 패킷 손실 없이 다른 TC의 deterministic 전송을 보장할 수 있음.
    close 구간이 LiDAR 패킷 간격(~781&micro;s) 대비 수십 배를 넘으면 버퍼 오버플로우 위험.</p>
  </div>
</div>

<!-- Jitter Diagnosis -->
<div class="card full" style="border-color: var(--accent2);">
  <h2 style="color: var(--accent2);">Jitter 원인 진단</h2>
  <div class="note" style="border-left-color: var(--accent2); margin-bottom:15px;">
    게이트가 전부 열려있는데도 stdev ~170&micro;s 수준의 jitter가 관측됨. 원인을 파악하기 위해
    TAS cycle time을 1ms/10ms/100ms로 변경하면서 all-open 상태의 jitter를 비교 측정.
  </div>

  <table class="result-table" id="diagTable"></table>

  <div style="margin-top:20px;">
    <h3 style="font-size:0.95em; color: var(--accent2); margin-bottom:10px;">결론</h3>
    <div style="font-size:0.9em; line-height:1.8;">
      <p><strong>TAS gate 전환은 원인이 아님.</strong> All-open 상태에서 cycle time을 1ms&rarr;10ms&rarr;100ms로 변경해도
      jitter(stdev)가 167~182&micro;s로 거의 동일. Gate 전환 주기와 무관한 일정한 jitter가 존재.</p>

      <p style="margin-top:10px;"><strong>원인 분석:</strong></p>
      <ul style="padding-left: 20px; color: var(--text2);">
        <li><strong>USB Ethernet 어댑터</strong>: URB (USB Request Block) 스케줄링 간격으로 인한 패킷 도착 시간 편차. USB 2.0/3.0 폴링 간격(125&micro;s~1ms)이 패킷 타이밍에 영향</li>
        <li><strong>스위치 Store-and-Forward</strong>: LAN9662는 cut-through가 아닌 store-and-forward 방식. 3,328B 패킷의 수신 완료 후 전달까지 ~26.6&micro;s + 가변 큐잉 지연</li>
        <li><strong>OS 스케줄링</strong>: Python socket.recvfrom() 호출 시 커널 &rarr; 유저스페이스 전환 지연</li>
      </ul>

      <p style="margin-top:10px;"><strong>정량 분석 (All-Open 평균):</strong></p>
      <ul style="padding-left: 20px; color: var(--text2);">
        <li>정상 범위(500~1200&micro;s): <strong>~91%</strong> &mdash; 대부분 정상</li>
        <li>P99 지연: <strong>~1270&micro;s</strong> (예상 781&micro;s 대비 +63%)</li>
        <li>Burst (&lt;50&micro;s): <strong>~0.2%</strong> &mdash; 프레임 경계 재동기화</li>
        <li>Large gap (&gt;1200&micro;s): <strong>~2.7%</strong> &mdash; OS/USB 스케줄링 지연</li>
      </ul>
    </div>
  </div>
</div>

<!-- Histogram Chart -->
<div class="card full">
  <h2>패킷 간격 분포 (All-Open vs Gated)</h2>
  <svg id="chartHistogram" height="350"></svg>
</div>

<!-- Per-frame jitter comparison -->
<div class="card full">
  <h2>Per-Frame Jitter 비교</h2>
  <svg id="chartPerFrame" height="300"></svg>
</div>

<!-- ================================================================== -->
<!-- COMPREHENSIVE TEST SUITE RESULTS -->
<!-- ================================================================== -->

<div class="section-divider">
  <h1>종합 테스트 스위트</h1>
  <div class="sub">6 categories &middot; 43 configs &middot; Sub-ms ~ 500ms cycle &middot; 2-4 GCL entries</div>
</div>

<!-- Comprehensive Summary Cards -->
<div class="findings">
  <div class="finding green">
    <div class="value">43</div>
    <div class="label">총 테스트 수<br>6개 카테고리</div>
  </div>
  <div class="finding green">
    <div class="value">36/43</div>
    <div class="label">패킷 수신 성공<br>(completeness &gt; 0)</div>
  </div>
  <div class="finding red">
    <div class="value">7</div>
    <div class="label">Total Loss<br>(0 packets)</div>
  </div>
  <div class="finding purple">
    <div class="value">13 min</div>
    <div class="label">총 측정 시간<br>(2026-02-24)</div>
  </div>
</div>

<!-- Category 1: Sub-Millisecond -->
<div class="card full" style="border-color: var(--green);">
  <h2 style="color: var(--green);">Cat 1: Sub-Millisecond Gating</h2>
  <div class="note" style="border-left-color: var(--green); margin-bottom:15px;">
    LiDAR 패킷 간격(781&micro;s)보다 짧은 TAS cycle 테스트. 게이트가 패킷 사이사이에서 열고 닫히므로
    개별 패킷 차단이 아닌 확률적 지연만 발생.
    <strong>결과: 10/10 전부 100% 수신.</strong>
  </div>
  <table class="result-table" id="subMsTable"></table>
  <svg id="chartSubMsJitter" height="280"></svg>
</div>

<!-- Category 2: Buffer Capacity -->
<div class="card full" style="border-color: var(--orange);">
  <h2 style="color: var(--orange);">Cat 2: Buffer Capacity Mapping</h2>
  <div class="note" style="border-left-color: var(--orange); margin-bottom:15px;">
    Close time을 점진적으로 늘려 버퍼 오버플로우 임계점을 탐색.
    <strong>발견: close 20ms 이상에서 패킷 손실 시작, 비결정적 패턴 (동기화 효과).</strong>
    25ms/35ms/45ms에서 total loss이나 20ms/30ms/40ms/50ms에서는 부분 수신 &mdash;
    TAS cycle과 LiDAR 주기의 beat frequency에 따라 결과가 극단적으로 갈림.
  </div>
  <table class="result-table" id="bufferTable"></table>
  <svg id="chartBufferThreshold" height="320"></svg>
</div>

<!-- Category 3: Frame-Aligned -->
<div class="card full" style="border-color: var(--accent);">
  <h2 style="color: var(--accent);">Cat 3: Frame-Aligned Gating (100ms = 1 Frame)</h2>
  <div class="note" style="border-left-color: var(--accent); margin-bottom:15px;">
    100ms cycle = LiDAR 1프레임(128 pkts) 정확히 동기. Close time이 40ms(~51 pkts)에 도달해도
    동기화 효과로 패킷이 open 구간에 집중.
    <strong>결과: 5/5 전부 100% 수신 (50% open까지!).</strong>
  </div>
  <table class="result-table" id="frameAlignedTable"></table>
  <svg id="chartFrameAligned" height="280"></svg>
</div>

<!-- Category 4: Multi-GCL -->
<div class="card full" style="border-color: var(--accent2);">
  <h2 style="color: var(--accent2);">Cat 4: Multi-GCL Entries</h2>
  <div class="note" style="border-left-color: var(--accent2); margin-bottom:15px;">
    2개 이상의 Gate Control List 항목으로 복잡한 게이트 스케줄 구성.
    <strong>결과: 짧은 open window(1ms)나 긴 close(20ms)가 포함되면 total loss 가능.</strong>
  </div>
  <table class="result-table" id="multiGclTable"></table>
  <svg id="chartMultiGcl" height="250"></svg>
</div>

<!-- Category 5: Endurance -->
<div class="card full" style="border-color: var(--yellow);">
  <h2 style="color: var(--yellow);">Cat 5: Endurance (60초 측정)</h2>
  <div class="note" style="border-left-color: var(--yellow); margin-bottom:15px;">
    60초 장시간 측정으로 통계 신뢰도 확보. 10초 테스트에서 51.6%였던 50ms/20%가
    60초에서는 <strong>0% (total loss)</strong> &mdash; 동기화 위상이 시간에 따라 변동하여
    장시간에서는 지속적 수신 불가.
  </div>
  <table class="result-table" id="enduranceTable"></table>
</div>

<!-- Category 6: Boundary -->
<div class="card full" style="border-color: var(--red);">
  <h2 style="color: var(--red);">Cat 6: Boundary Conditions</h2>
  <div class="note" style="border-left-color: var(--red); margin-bottom:15px;">
    극한 파라미터: 1ms cycle에서 99%/98%/95%/90% open (close 10~100&micro;s),
    200ms/80% (40ms close), 500ms/50% (250ms close).
    <strong>결과: 500ms/50% 250ms close에서도 100% 수신 &mdash; 동기화 효과.</strong>
  </div>
  <table class="result-table" id="boundaryTable"></table>
</div>

<!-- Comprehensive Heatmap -->
<div class="card full">
  <h2>Completeness Heatmap: Close Time vs Cycle Time</h2>
  <svg id="chartHeatmap" height="400"></svg>
  <div class="note" style="margin-top:10px;">
    Close time이 ~20ms를 초과하면 손실 위험 시작. 그러나 TAS cycle과 LiDAR 주기의
    beat frequency 동기화에 따라 동일한 close time에서도 결과가 극단적으로 달라질 수 있음
    (25ms/35ms/45ms = 0%, 30ms/40ms/50ms = 부분 수신).
  </div>
</div>

<!-- Design Guidelines -->
<div class="card full" style="border-color: var(--green);">
  <h2 style="color: var(--green);">TSN 설계 가이드라인</h2>
  <div class="guideline-grid">
    <div class="guideline-box do">
      <h3 style="color: var(--green);">DO</h3>
      <ul>
        <li>Close time &le; 10ms 유지 (안전 영역)</li>
        <li>Sub-ms cycle 자유롭게 사용 가능 (100~781&micro;s 전부 100%)</li>
        <li>LiDAR 프레임 주기(100ms)의 정수배 cycle 활용</li>
        <li>Open &ge; 50% 할당 시 대부분의 설정에서 안전</li>
        <li>Multi-GCL 사용 시 개별 open window &ge; 2ms 확보</li>
        <li>Burst 수신 대비 RX 버퍼 16MB 이상 설정</li>
      </ul>
    </div>
    <div class="guideline-box dont">
      <h3 style="color: var(--red);">DON'T</h3>
      <ul>
        <li>Close time &ge; 20ms 사용 금지 (버퍼 오버플로우)</li>
        <li>Multi-GCL에서 1ms 이하 open window 사용 금지 (total loss)</li>
        <li>50ms/20% 등 장시간 close는 단기 테스트도 불안정</li>
        <li>Beat frequency 동기화에 의존한 설계 금지 (비결정적)</li>
        <li>단일 TC에 전체 close 할당 시 해당 TC 트래픽 완전 차단 위험</li>
        <li>장시간 운영에서 10초 테스트 결과 외삽 금지</li>
      </ul>
    </div>
  </div>
</div>

<!-- Key Discovery -->
<div class="card full" style="border-color: var(--accent2); background: rgba(124,92,252,0.05);">
  <h2 style="color: var(--accent2);">핵심 발견: Beat Frequency 동기화</h2>
  <div style="font-size:0.9em; line-height:1.8;">
    <p>종합 테스트에서 가장 중요한 발견은 <strong>TAS cycle과 LiDAR 패킷 주기 간의 beat frequency 동기화</strong>입니다.</p>

    <p style="margin-top:10px;"><strong>현상:</strong></p>
    <ul style="padding-left: 20px; color: var(--text2);">
      <li>동일한 open %(20%)에서 25ms = <span style="color:var(--red)">0%</span>, 30ms = <span style="color:var(--orange)">72%</span>,
          35ms = <span style="color:var(--red)">0%</span>, 40ms = <span style="color:var(--orange)">58%</span> &mdash; 교대로 성공/실패</li>
      <li>500ms/50% (250ms close)에서도 <span style="color:var(--green)">100%</span> 수신 &mdash; close 시간보다 동기화가 결정적</li>
      <li>100ms cycle (= LiDAR frame period)에서 50%까지 <span style="color:var(--green)">100%</span> &mdash; 완벽 동기화</li>
    </ul>

    <p style="margin-top:10px;"><strong>원인:</strong></p>
    <p style="color: var(--text2);">LiDAR는 자유 구동(free-running) 클럭으로 781&micro;s 간격 패킷을 전송.
    TAS gate는 독립 클럭으로 동작. 두 주기의 최소공배수(LCM)에 따라 패킷이 gate-open 구간에
    집중되거나 분산됨. 이 관계가 정수비에 가까우면 대부분의 패킷이 open 구간에 도착하여
    close time이 길어도 손실이 발생하지 않음.</p>

    <p style="margin-top:10px;"><strong>실무 의미:</strong></p>
    <p style="color: var(--text2);">이 동기화 효과는 <strong>비결정적(non-deterministic)</strong>이므로 안전 설계에 의존해서는 안 됨.
    환경 변화(온도, 클럭 드리프트)에 따라 동기화가 깨질 수 있으며, 장시간 운영 시
    위상 관계가 변동하여 갑작스러운 패킷 손실 발생 가능. 10초 단기 테스트와 60초 장기 테스트의
    결과 차이(50ms/20%: 51.6% vs 0%)가 이를 증명.</p>
  </div>
</div>

<!-- ================================================================== -->
<!-- MULTI-TC TAS SCHEDULING (ROII-Style) -->
<!-- ================================================================== -->

<div class="section-divider">
  <h1>Multi-TC TAS 스케줄링</h1>
  <div class="sub">ROII-Style Per-TC Gate Bitmask &middot; 5 categories &middot; 30 tests &middot; Automotive Sensor Profiles</div>
</div>

<!-- Multi-TC Overview -->
<div class="card full" style="border-color: var(--accent);">
  <h2>ROII 센서-TC 매핑 &amp; Gate Bitmask</h2>
  <div style="font-size:0.9em; line-height:1.8; margin-bottom:15px;">
    <p>자동차 자율주행 네트워크(ROII)에서 각 센서는 고유한 Traffic Class(TC)에 매핑됩니다.
    LAN9662의 8-bit gate-states-value를 사용하여 per-TC 시간 슬롯을 제어합니다.</p>
  </div>
  <div style="display:flex; gap:15px; flex-wrap:wrap; margin-bottom:15px;">
    <div class="setup-box" style="background:#1a3a2a; border:1px solid var(--green); flex:1; min-width:130px;">
      <div><strong>TC0 (0x01)</strong></div>
      <div class="setup-label">LiDAR<br>Ouster OS-1<br>34 Mbps</div>
    </div>
    <div class="setup-box" style="background:#2a2a1a; border:1px solid var(--yellow); flex:1; min-width:130px;">
      <div><strong>TC6 (0x40)</strong></div>
      <div class="setup-label">Radar<br>MRR-35<br>1.3 Mbps</div>
    </div>
    <div class="setup-box" style="background:#2a1a2a; border:1px solid var(--accent2); flex:1; min-width:130px;">
      <div><strong>TC5 (0x20)</strong></div>
      <div class="setup-label">Camera<br>Simulated<br>20 Mbps</div>
    </div>
    <div class="setup-box" style="background:#1a2a3a; border:1px solid var(--accent); flex:1; min-width:130px;">
      <div><strong>TC2 (0x04)</strong></div>
      <div class="setup-label">Control<br>CAN/Ethernet<br>0.5 Mbps</div>
    </div>
    <div class="setup-box" style="background:#2a2a2a; border:1px solid #666; flex:1; min-width:130px;">
      <div><strong>0xFF (Guard)</strong></div>
      <div class="setup-label">All TCs Open<br>Guard Band<br>TC0 포함</div>
    </div>
  </div>
  <table class="spec-table">
    <tr><th>Gate Value</th><th>Binary</th><th>Open TC</th><th>용도</th></tr>
    <tr><td>0x01</td><td style="font-family:monospace;color:var(--green)">00000001</td><td>TC0</td><td>LiDAR 전용 슬롯</td></tr>
    <tr><td>0x40</td><td style="font-family:monospace;color:var(--yellow)">01000000</td><td>TC6</td><td>Radar 시뮬레이션</td></tr>
    <tr><td>0x20</td><td style="font-family:monospace;color:var(--accent2)">00100000</td><td>TC5</td><td>Camera 시뮬레이션</td></tr>
    <tr><td>0x04</td><td style="font-family:monospace;color:var(--accent)">00000100</td><td>TC2</td><td>Control 시뮬레이션</td></tr>
    <tr><td>0xFF</td><td style="font-family:monospace;color:#888">11111111</td><td>전체</td><td>Guard band (TC0 포함!)</td></tr>
  </table>
  <div class="note" style="margin-top:15px;">
    실제 트래픽은 LiDAR(TC0)뿐이지만, 다른 TC gate가 열려도 TC0은 해당 슬롯에서 차단됩니다.
    Guard band(0xFF)는 TC0을 포함하므로 실질 TC0 시간 = TC0 슬롯 + Guard 슬롯.
  </div>
</div>

<!-- Multi-TC Summary Cards -->
<div class="findings">
  <div class="finding green">
    <div class="value">30</div>
    <div class="label">Multi-TC 테스트<br>5개 카테고리</div>
  </div>
  <div class="finding green">
    <div class="value">25/30</div>
    <div class="label">100% 수신<br>(beat freq 영향 5건)</div>
  </div>
  <div class="finding orange">
    <div class="value">Beat</div>
    <div class="label">비결정적 동기화<br>TC0%와 무관</div>
  </div>
  <div class="finding purple">
    <div class="value">6.2 min</div>
    <div class="label">총 측정 시간<br>(2026-02-24)</div>
  </div>
</div>

<!-- Cat A: TC0 Allocation Sweep -->
<div class="card full" style="border-color: var(--green);">
  <h2 style="color: var(--green);">Cat A: TC0 Allocation Sweep</h2>
  <div class="note" style="border-left-color: var(--green); margin-bottom:15px;">
    10ms cycle, 3-entry: TC0(0x01) &rarr; TC6(0x40) &rarr; TC2(0x04).
    TC0 할당을 1ms(10%)~8ms(80%)까지 sweep.
    <strong>발견: TC0=2ms, 4ms에서 total loss &mdash; beat frequency 효과!</strong>
    TC0% 증가가 반드시 개선을 의미하지 않음.
  </div>
  <table class="result-table" id="tc0SweepTable"></table>
  <svg id="chartTc0Sweep" height="350"></svg>
</div>

<!-- Cat B: Fragmentation Effect -->
<div class="card full" style="border-color: var(--accent);">
  <h2 style="color: var(--accent);">Cat B: Fragmentation Effect</h2>
  <div class="note" style="border-left-color: var(--accent); margin-bottom:15px;">
    동일한 TC0 총 시간(4ms, 40%)을 다르게 분배. 1개 블록 vs 여러 블록.
    <strong>핵심 발견: 분산 배치(2&times;2ms, 5&times;1ms)가 집중 배치(1&times;4ms)보다 훨씬 안정적!</strong>
    Jitter: 1749&micro;s(1&times;4ms) &rarr; 181&micro;s(2&times;2ms) &rarr; 162&micro;s(5&times;1ms).
  </div>
  <table class="result-table" id="fragTable"></table>
  <svg id="chartFragGantt" height="300"></svg>
  <svg id="chartFragCompare" height="300"></svg>
</div>

<!-- Cat C: Cycle Time Scaling -->
<div class="card full" style="border-color: var(--accent2);">
  <h2 style="color: var(--accent2);">Cat C: Cycle Time Scaling (ROII 비율 고정)</h2>
  <div class="note" style="border-left-color: var(--accent2); margin-bottom:15px;">
    ROII 비율 고정: TC0=40%, TC6=30%, TC2=20%, Guard=10%. Cycle만 2ms&rarr;100ms.
    <strong>20ms와 100ms에서 baseline급 안정 (stdev 160~175&micro;s). 50ms에서 close=25ms로 burst 증가.</strong>
    TC0 effective open = 40% + 10%(guard) = 50%.
  </div>
  <table class="result-table" id="cycleScaleTable"></table>
  <svg id="chartCycleScale" height="300"></svg>
</div>

<!-- Cat D: ROII Realistic Profiles -->
<div class="card full" style="border-color: var(--yellow);">
  <h2 style="color: var(--yellow);">Cat D: ROII Realistic Profiles</h2>
  <div class="note" style="border-left-color: var(--yellow); margin-bottom:15px;">
    10ms cycle, 5개 자동차 센서 프로필. 5-entry GCL: TC0 &rarr; TC6 &rarr; TC5 &rarr; TC2 &rarr; Guard.
    <strong>LiDAR-Heavy(TC0=6ms+Guard=1ms=70%)가 가장 안정. Camera-Heavy에서 total loss(beat freq).</strong>
  </div>
  <table class="result-table" id="roiiTable"></table>
  <svg id="chartRoiiGantt" height="300"></svg>
  <svg id="chartRoiiCompare" height="300"></svg>
</div>

<!-- Cat E: Guard Band Effect -->
<div class="card full" style="border-color: var(--orange);">
  <h2 style="color: var(--orange);">Cat E: Guard Band Effect</h2>
  <div class="note" style="border-left-color: var(--orange); margin-bottom:15px;">
    TC0=4ms 고정, Guard band(0xFF) 크기 변화. Guard는 TC0 포함이므로 effective TC0 증가.
    <strong>Guard=2ms(eff 60%)에서 total loss, Guard=3ms(eff 70%)에서 100% &mdash; beat frequency.</strong>
    Guard band 자체가 TC0 open 역할도 함.
  </div>
  <table class="result-table" id="guardTable"></table>
  <svg id="chartGuard" height="300"></svg>
</div>

<!-- Multi-TC Key Discovery -->
<div class="card full" style="border-color: var(--accent2); background: rgba(124,92,252,0.05);">
  <h2 style="color: var(--accent2);">핵심 발견: Per-TC Bitmask vs Beat Frequency</h2>
  <div style="font-size:0.9em; line-height:1.8;">
    <p><strong>Per-TC gate bitmask를 사용해도 beat frequency 동기화 효과는 동일하게 나타남.</strong></p>

    <p style="margin-top:10px;"><strong>1. TC0 open % 증가 &ne; 안정성 증가</strong></p>
    <ul style="padding-left: 20px; color: var(--text2);">
      <li>TC0=1ms(10%) = <span style="color:var(--green)">100%</span>, TC0=2ms(20%) = <span style="color:var(--red)">0%</span>, TC0=3ms(30%) = <span style="color:var(--green)">100%</span></li>
      <li>gate-states-value가 달라도 TC0 bit가 열려있는 시간의 절대값과 위상이 결정적</li>
    </ul>

    <p style="margin-top:10px;"><strong>2. 분산 배치가 집중 배치보다 유리</strong></p>
    <ul style="padding-left: 20px; color: var(--text2);">
      <li>1&times;4ms: burst 51.2%, stdev 1749&micro;s</li>
      <li>2&times;2ms: burst 0.2%, stdev 181&micro;s &mdash; <span style="color:var(--green)">10배 개선!</span></li>
      <li>5&times;1ms: burst 0.2%, stdev 162&micro;s &mdash; 거의 baseline</li>
    </ul>

    <p style="margin-top:10px;"><strong>3. Guard Band = 실질적 TC0 확장</strong></p>
    <ul style="padding-left: 20px; color: var(--text2);">
      <li>Guard band(0xFF)에서 TC0도 열리므로, Guard 시간이 TC0 effective time에 추가</li>
      <li>Guard=6ms → effective TC0=10ms(100%) → baseline과 동일</li>
    </ul>

    <p style="margin-top:10px;"><strong>4. ROII 설계 권장</strong></p>
    <ul style="padding-left: 20px; color: var(--text2);">
      <li>LiDAR-Heavy 프로필(TC0=6ms+Guard=1ms=70%) 권장</li>
      <li>TC0 슬롯을 2개 이상으로 분산 배치 (beat frequency 회피)</li>
      <li>Guard band를 TC0 슬롯 직후에 배치하여 transition margin 확보</li>
    </ul>
  </div>
</div>

<!-- Multi-TC Design Guidelines -->
<div class="card full" style="border-color: var(--green);">
  <h2 style="color: var(--green);">Multi-TC TSN 설계 가이드라인</h2>
  <div class="guideline-grid">
    <div class="guideline-box do">
      <h3 style="color: var(--green);">DO</h3>
      <ul>
        <li>TC0 슬롯을 2개 이상으로 분산 배치 (jitter 10배 감소)</li>
        <li>Guard band(0xFF)를 TC0 직후에 배치 (effective TC0 증가)</li>
        <li>LiDAR TC에 &ge; 60% effective open 할당</li>
        <li>20ms 또는 100ms cycle 사용 (beat frequency 동기화)</li>
        <li>LiDAR-Heavy 프로필 기본 채택 (TC0=6ms+Guard=1ms)</li>
      </ul>
    </div>
    <div class="guideline-box dont">
      <h3 style="color: var(--red);">DON'T</h3>
      <ul>
        <li>TC0를 1개 연속 블록으로 할당 (burst 50%+)</li>
        <li>beat frequency에 의존한 TC0 할당 (비결정적)</li>
        <li>Guard band 없이 TC0 직후 다른 TC로 전환</li>
        <li>Camera-Heavy 처럼 TC0 &lt; 30% 할당 (total loss 위험)</li>
        <li>50ms cycle 사용 (close 25ms &rarr; 버퍼 위험)</li>
      </ul>
    </div>
  </div>
</div>

</div>

<script>
// ══════════════════════════════════════════════════════════════
// ORIGINAL DATA (13-config sweep)
// ══════════════════════════════════════════════════════════════
const data = [
  { label: "Baseline", cycle: 0, open: 0, close: 0, openPct: 100, complete: 100, pps: 1280, gapMean: 781, gapSD: 159, gapMax: 1681, p99: 1200, burst: 0.1 },
  { label: "1ms/80%", cycle: 1000, open: 800, close: 200, openPct: 80, complete: 100, pps: 1280, gapMean: 781, gapSD: 240, gapMax: 1811, p99: 1321, burst: 0.6 },
  { label: "1ms/50%", cycle: 1000, open: 500, close: 500, openPct: 50, complete: 100, pps: 1280, gapMean: 781, gapSD: 344, gapMax: 1524, p99: 1295, burst: 5.3 },
  { label: "1ms/20%", cycle: 1000, open: 200, close: 800, openPct: 20, complete: 100, pps: 1280, gapMean: 781, gapSD: 422, gapMax: 2061, p99: 1337, burst: 22.0 },
  { label: "5ms/80%", cycle: 5000, open: 4000, close: 1000, openPct: 80, complete: 100, pps: 1280, gapMean: 781, gapSD: 450, gapMax: 2301, p99: 1915, burst: 10.0 },
  { label: "5ms/50%", cycle: 5000, open: 2500, close: 2500, openPct: 50, complete: 100, pps: 1280, gapMean: 781, gapSD: 168, gapMax: 1735, p99: 1271, burst: 0.2 },
  { label: "5ms/20%", cycle: 5000, open: 1000, close: 4000, openPct: 20, complete: 100, pps: 1280, gapMean: 781, gapSD: 1652, gapMax: 5282, p99: 4952, burst: 68.9 },
  { label: "10ms/80%", cycle: 10000, open: 8000, close: 2000, openPct: 80, complete: 100, pps: 1280, gapMean: 781, gapSD: 180, gapMax: 1809, p99: 1284, burst: 0.3 },
  { label: "10ms/50%", cycle: 10000, open: 5000, close: 5000, openPct: 50, complete: 100, pps: 1280, gapMean: 781, gapSD: 1431, gapMax: 6243, p99: 5770, burst: 41.4 },
  { label: "10ms/20%", cycle: 10000, open: 2000, close: 8000, openPct: 20, complete: 100, pps: 1280, gapMean: 781, gapSD: 158, gapMax: 1668, p99: 1256, burst: 0.2 },
  { label: "50ms/80%", cycle: 50000, open: 40000, close: 10000, openPct: 80, complete: 100, pps: 1280, gapMean: 781, gapSD: 1267, gapMax: 11268, p99: 10397, burst: 17.2 },
  { label: "50ms/50%", cycle: 50000, open: 25000, close: 25000, openPct: 50, complete: 100, pps: 1280, gapMean: 781, gapSD: 171, gapMax: 1841, p99: 1264, burst: 0.1 },
  { label: "50ms/20%", cycle: 50000, open: 10000, close: 40000, openPct: 20, complete: 51.6, pps: 660, gapMean: 1515, gapSD: 6922, gapMax: 41066, p99: 40669, burst: 55.1 },
];

const cycleColors = { 0: '#8899aa', 1000: '#00d2ff', 5000: '#7c5cfc', 10000: '#00e676', 50000: '#ff5252' };
function getColor(d) { return cycleColors[d.cycle] || '#ffffff'; }

// Result table
const table = d3.select('#resultTable');
const thead = table.append('thead').append('tr');
['Config', 'Cycle', 'Open%', 'Cmpl%', 'PPS', 'Gap Mean', 'Gap SD', 'P99', 'Max Gap', 'Burst%'].forEach(h =>
  thead.append('th').text(h));
const tbody = table.append('tbody');
data.forEach(d => {
  const tr = tbody.append('tr').classed('baseline', d.cycle === 0);
  tr.append('td').text(d.label);
  tr.append('td').text(d.cycle === 0 ? '\u2014' : (d.cycle/1000)+'ms');
  tr.append('td').text(d.openPct + '%');
  const cmplTd = tr.append('td').text(d.complete.toFixed(1) + '%');
  if (d.complete < 100) cmplTd.classed('loss', true);
  tr.append('td').text(d.pps.toFixed(0));
  tr.append('td').text(d.gapMean.toFixed(0) + '\u00b5s');
  tr.append('td').text(d.gapSD.toFixed(0) + '\u00b5s');
  tr.append('td').text(d.p99.toFixed(0) + '\u00b5s');
  tr.append('td').text(d.gapMax.toFixed(0) + '\u00b5s');
  tr.append('td').text(d.burst.toFixed(1) + '%');
});

// Generic bar chart
function barChart(svgId, dataset, metric, yLabel, fmt, colorFn) {
  const svg = d3.select('#' + svgId);
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 20, right: 30, bottom: 60, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = parseInt(svg.attr('height')) - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const x = d3.scaleBand().domain(dataset.map(d => d.label)).range([0, w]).padding(0.3);
  const yMax = d3.max(dataset, d => d[metric]) * 1.15 || 1;
  const y = d3.scaleLinear().domain([0, yMax]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class', 'grid-line')
    .attr('x1', 0).attr('x2', w).attr('y1', d => y(d)).attr('y2', d => y(d));

  g.selectAll('rect').data(dataset).enter().append('rect')
    .attr('x', d => x(d.label))
    .attr('y', d => y(d[metric]))
    .attr('width', x.bandwidth())
    .attr('height', d => h - y(d[metric]))
    .attr('fill', colorFn || (d => getColor(d)))
    .attr('rx', 3)
    .attr('opacity', 0.85);

  g.selectAll('.val').data(dataset).enter().append('text')
    .attr('x', d => x(d.label) + x.bandwidth()/2)
    .attr('y', d => y(d[metric]) - 5)
    .attr('text-anchor', 'middle')
    .attr('fill', '#c8d6e5')
    .attr('font-size', '10px')
    .text(d => fmt ? fmt(d[metric]) : d[metric]);

  g.append('g').attr('class', 'axis').attr('transform', `translate(0,${h})`)
    .call(d3.axisBottom(x))
    .selectAll('text').attr('transform', 'rotate(-35)').style('text-anchor', 'end');

  g.append('g').attr('class', 'axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('transform', 'rotate(-90)')
    .attr('x', -h/2).attr('y', -55)
    .attr('text-anchor', 'middle').attr('fill', '#8899aa').attr('font-size', '12px')
    .text(yLabel);
}

// Original charts
barChart('chartComplete', data, 'complete', 'Completeness (%)', v => v.toFixed(1)+'%',
  d => d.complete < 100 ? '#ff5252' : getColor(d));
barChart('chartJitter', data, 'gapSD', 'Jitter \u2014 Gap StdDev (\u00b5s)', v => v.toFixed(0));
barChart('chartBurst', data, 'burst', 'Burst Rate (%)', v => v.toFixed(1)+'%');
barChart('chartMaxGap', data, 'gapMax', 'Max Inter-Packet Gap (\u00b5s)', v =>
  v >= 1000 ? (v/1000).toFixed(1)+'ms' : v.toFixed(0)+'\u00b5s');

// ── Jitter Diagnosis Data ──
const diagData = [
  { label: "All-Open (1ms)", cycle: 1000, pkts: 12801, mean: 781.3, stdev: 173.0, p99: 1271, max: 1980, burst: 0.3, normal: 91.3, large: 2.6, pfJitter: 154.1, pfMin: 13.6, pfMax: 374.6 },
  { label: "All-Open (10ms)", cycle: 10000, pkts: 12801, mean: 781.2, stdev: 182.2, p99: 1282, max: 1775, burst: 0.2, normal: 89.4, large: 3.3, pfJitter: 161.5, pfMin: 13.3, pfMax: 403.2 },
  { label: "All-Open (100ms)", cycle: 100000, pkts: 12801, mean: 781.3, stdev: 166.7, p99: 1251, max: 1800, burst: 0.2, normal: 91.2, large: 2.4, pfJitter: 156.3, pfMin: 7.3, pfMax: 379.6 },
  { label: "1ms / 80%", cycle: 1000, pkts: 12801, mean: 781.2, stdev: 234.5, p99: 1287, max: 2164, burst: 0.4, normal: 84.5, large: 2.6, pfJitter: 225.2, pfMin: 102.6, pfMax: 393.4 },
  { label: "1ms / 50%", cycle: 1000, pkts: 12801, mean: 781.2, stdev: 342.6, p99: 1304, max: 1995, burst: 4.2, normal: 75.3, large: 2.3, pfJitter: 333.8, pfMin: 218.4, pfMax: 451.3 },
  { label: "5ms / 80%", cycle: 5000, pkts: 12801, mean: 781.3, stdev: 443.5, p99: 1919, max: 2521, burst: 10.3, normal: 63.9, large: 15.5, pfJitter: 295.3, pfMin: 186.3, pfMax: 457.0 },
  { label: "10ms / 50%", cycle: 10000, pkts: 12800, mean: 781.3, stdev: 165.6, p99: 1265, max: 1932, burst: 0.2, normal: 91.5, large: 2.5, pfJitter: 149.4, pfMin: 29.7, pfMax: 358.8 },
  { label: "50ms / 20%", cycle: 50000, pkts: 6532, mean: 1531.2, stdev: 6963.4, p99: 40878, max: 41625, burst: 56.5, normal: 33.9, large: 3.6, pfJitter: 357.7, pfMin: 122.1, pfMax: 398.7 },
];

// Diagnosis table
const dt = d3.select('#diagTable');
const dHead = dt.append('thead').append('tr');
['Config', 'Packets', 'Gap Mean', 'StdDev', 'P99', 'Max', 'Burst%', 'Normal%', 'Frame Jitter'].forEach(h =>
  dHead.append('th').text(h));
const dBody = dt.append('tbody');
diagData.forEach(d => {
  const tr = dBody.append('tr');
  const isOpen = d.label.startsWith('All-Open');
  if (isOpen) tr.style('background', 'rgba(124,92,252,0.08)');
  tr.append('td').text(d.label);
  tr.append('td').text(d.pkts.toLocaleString());
  tr.append('td').text(d.mean.toFixed(0) + '\u00b5s');
  const sdTd = tr.append('td').text(d.stdev.toFixed(0) + '\u00b5s');
  if (isOpen) sdTd.style('color', '#7c5cfc').style('font-weight', 'bold');
  tr.append('td').text(d.p99.toFixed(0) + '\u00b5s');
  tr.append('td').text(d.max >= 10000 ? (d.max/1000).toFixed(1)+'ms' : d.max.toFixed(0) + '\u00b5s');
  tr.append('td').text(d.burst.toFixed(1) + '%');
  tr.append('td').text(d.normal.toFixed(1) + '%');
  tr.append('td').text(d.pfJitter.toFixed(0) + '\u00b5s');
});

// ── Histogram: All-Open vs Gated ──
(function() {
  const histBins = ['<50', '50-200', '200-600', '600-780', '780-850', '850-1200', '>1200'];
  const openHist = [0.2, 0.3, 8.6, 35.7, 35.4, 12.4, 2.4];
  const gatedHist = [4.2, 7.2, 12.5, 4.5, 12.1, 56.5, 2.4];
  const lossHist = [56.5, 4.3, 2.9, 17.1, 12.3, 2.8, 3.6];

  const svg = d3.select('#chartHistogram');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 20, bottom: 60, left: 60 };
  const w = bbox.width - margin.left - margin.right;
  const h = 350 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const x0 = d3.scaleBand().domain(histBins).range([0, w]).padding(0.25);
  const x1 = d3.scaleBand().domain(['open','gated','loss']).range([0, x0.bandwidth()]).padding(0.05);
  const y = d3.scaleLinear().domain([0, 60]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>y(d)).attr('y2',d=>y(d));

  const colors = { open: '#7c5cfc', gated: '#00d2ff', loss: '#ff5252' };
  const datasets = [
    { key: 'open', data: openHist, label: 'All-Open (100ms)' },
    { key: 'gated', data: gatedHist, label: '1ms / 50%' },
    { key: 'loss', data: lossHist, label: '50ms / 20%' },
  ];

  histBins.forEach((bin, i) => {
    datasets.forEach(ds => {
      g.append('rect')
        .attr('x', x0(bin) + x1(ds.key))
        .attr('y', y(ds.data[i]))
        .attr('width', x1.bandwidth())
        .attr('height', h - y(ds.data[i]))
        .attr('fill', colors[ds.key])
        .attr('opacity', 0.8)
        .attr('rx', 2);
    });
  });

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x0)).selectAll('text').attr('font-size','10px');
  g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-45)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Packets (%)');
  g.append('text').attr('x',w/2).attr('y',h+45)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Inter-Packet Gap (\u00b5s)');

  const leg = g.append('g').attr('transform', `translate(${w-250}, -10)`);
  datasets.forEach((ds, i) => {
    leg.append('rect').attr('x', i*90).attr('y',0).attr('width',10).attr('height',10).attr('fill',colors[ds.key]).attr('rx',2);
    leg.append('text').attr('x', i*90+14).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text(ds.label);
  });
})();

// ── Per-frame jitter chart ──
(function() {
  const svg = d3.select('#chartPerFrame');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 20, right: 30, bottom: 60, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 300 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const x = d3.scaleBand().domain(diagData.map(d=>d.label)).range([0, w]).padding(0.2);
  const y = d3.scaleLinear().domain([0, 500]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>y(d)).attr('y2',d=>y(d));

  diagData.filter(d=>d.label!=='50ms / 20%').forEach(d => {
    const cx = x(d.label) + x.bandwidth()/2;
    g.append('line').attr('x1',cx).attr('x2',cx)
      .attr('y1',y(d.pfMin)).attr('y2',y(d.pfMax))
      .attr('stroke','#445').attr('stroke-width',2);
    g.append('line').attr('x1',cx-6).attr('x2',cx+6).attr('y1',y(d.pfMin)).attr('y2',y(d.pfMin)).attr('stroke','#445').attr('stroke-width',2);
    g.append('line').attr('x1',cx-6).attr('x2',cx+6).attr('y1',y(d.pfMax)).attr('y2',y(d.pfMax)).attr('stroke','#445').attr('stroke-width',2);
  });

  g.selectAll('.dot').data(diagData.filter(d=>d.label!=='50ms / 20%')).enter()
    .append('circle')
    .attr('cx', d => x(d.label) + x.bandwidth()/2)
    .attr('cy', d => y(d.pfJitter))
    .attr('r', 6)
    .attr('fill', d => d.label.startsWith('All-Open') ? '#7c5cfc' : '#00d2ff')
    .attr('stroke', '#fff').attr('stroke-width', 1.5);

  g.selectAll('.val').data(diagData.filter(d=>d.label!=='50ms / 20%')).enter()
    .append('text')
    .attr('x', d => x(d.label) + x.bandwidth()/2)
    .attr('y', d => y(d.pfJitter) - 12)
    .attr('text-anchor', 'middle').attr('fill', '#c8d6e5').attr('font-size', '10px')
    .text(d => d.pfJitter.toFixed(0) + '\u00b5s');

  g.append('rect').attr('x',0).attr('y',y(182)).attr('width',w).attr('height',y(155)-y(182))
    .attr('fill','#7c5cfc').attr('opacity',0.1);
  g.append('text').attr('x',w-5).attr('y',y(175)).attr('text-anchor','end')
    .attr('fill','#7c5cfc').attr('font-size','9px').text('All-Open baseline band');

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x)).selectAll('text').attr('transform','rotate(-30)').style('text-anchor','end');
  g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Per-Frame Jitter StdDev (\u00b5s)');
})();


// ══════════════════════════════════════════════════════════════
// COMPREHENSIVE TEST DATA
// ══════════════════════════════════════════════════════════════

const subMsData = [
  { label: "100\u00b5s/80%", cycle: 100, openPct: 80, pkts: 12801, complete: 100, gapSD: 140, p99: 1253, gapMax: 1759, burst: 0.1, normal: 94.6 },
  { label: "100\u00b5s/50%", cycle: 100, openPct: 50, pkts: 12801, complete: 100, gapSD: 159, p99: 1291, gapMax: 1817, burst: 0.2, normal: 92.7 },
  { label: "250\u00b5s/80%", cycle: 250, openPct: 80, pkts: 12800, complete: 100, gapSD: 177, p99: 1275, gapMax: 1747, burst: 0.2, normal: 92.1 },
  { label: "250\u00b5s/50%", cycle: 250, openPct: 50, pkts: 12801, complete: 100, gapSD: 90, p99: 1041, gapMax: 1357, burst: 0.0, normal: 99.9 },
  { label: "500\u00b5s/80%", cycle: 500, openPct: 80, pkts: 12801, complete: 100, gapSD: 227, p99: 1353, gapMax: 1876, burst: 0.3, normal: 87.6 },
  { label: "500\u00b5s/50%", cycle: 500, openPct: 50, pkts: 12801, complete: 100, gapSD: 310, p99: 1451, gapMax: 2151, burst: 1.1, normal: 71.5 },
  { label: "750\u00b5s/80%", cycle: 750, openPct: 80, pkts: 12800, complete: 100, gapSD: 206, p99: 1349, gapMax: 1898, burst: 0.4, normal: 88.2 },
  { label: "750\u00b5s/50%", cycle: 750, openPct: 50, pkts: 12801, complete: 100, gapSD: 226, p99: 1497, gapMax: 1953, burst: 1.0, normal: 87.2 },
  { label: "781\u00b5s/80%", cycle: 781, openPct: 80, pkts: 12801, complete: 100, gapSD: 180, p99: 1317, gapMax: 1807, burst: 0.3, normal: 90.4 },
  { label: "781\u00b5s/50%", cycle: 781, openPct: 50, pkts: 12801, complete: 100, gapSD: 206, p99: 1448, gapMax: 2040, burst: 0.8, normal: 88.4 },
];

const bufferData = [
  { label: "10ms/20%", cycle: 10, close: 8, pkts: 12801, complete: 100, gapSD: 2287, p99: 8871, gapMax: 9436, burst: 73.6, pps: 1280 },
  { label: "15ms/20%", cycle: 15, close: 12, pkts: 12802, complete: 100, gapSD: 164, p99: 1262, gapMax: 1814, burst: 0.1, pps: 1280 },
  { label: "20ms/20%", cycle: 20, close: 16, pkts: 12468, complete: 100, gapSD: 3250, p99: 16834, gapMax: 17404, burst: 72.7, pps: 1247 },
  { label: "25ms/20%", cycle: 25, close: 20, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, pps: 0 },
  { label: "30ms/20%", cycle: 30, close: 24, pkts: 9167, complete: 71.6, gapSD: 4588, p99: 24847, gapMax: 25888, burst: 64.9, pps: 917 },
  { label: "35ms/20%", cycle: 35, close: 28, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, pps: 0 },
  { label: "40ms/20%", cycle: 40, close: 32, pkts: 7470, complete: 58.4, gapSD: 5843, p99: 32838, gapMax: 33353, burst: 59.7, pps: 747 },
  { label: "45ms/20%", cycle: 45, close: 36, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, pps: 0 },
  { label: "50ms/20%", cycle: 50, close: 40, pkts: 6530, complete: 51.0, gapSD: 6973, p99: 40744, gapMax: 41375, burst: 55.7, pps: 653 },
  { label: "50ms/25%", cycle: 50, close: 37.5, pkts: 12801, complete: 100, gapSD: 166, p99: 1267, gapMax: 1745, burst: 0.2, pps: 1280 },
  { label: "50ms/30%", cycle: 50, close: 35, pkts: 7801, complete: 60.9, gapSD: 5572, p99: 35536, gapMax: 36453, burst: 46.1, pps: 780 },
  { label: "50ms/35%", cycle: 50, close: 32.5, pkts: 12801, complete: 100, gapSD: 176, p99: 1272, gapMax: 1759, burst: 0.3, pps: 1280 },
  { label: "50ms/40%", cycle: 50, close: 30, pkts: 9152, complete: 71.5, gapSD: 4428, p99: 30503, gapMax: 31903, burst: 39.6, pps: 915 },
];

const frameAlignedData = [
  { label: "100ms/90%", close: 10, pkts: 12801, complete: 100, gapSD: 168, p99: 1262, gapMax: 1734, burst: 0.2, normal: 91.5 },
  { label: "100ms/80%", close: 20, pkts: 12203, complete: 100, gapSD: 1827, p99: 1392, gapMax: 21077, burst: 14.5, normal: 77.8 },
  { label: "100ms/70%", close: 30, pkts: 12801, complete: 100, gapSD: 177, p99: 1272, gapMax: 1965, burst: 0.2, normal: 90.4 },
  { label: "100ms/60%", close: 40, pkts: 9676, complete: 100, gapSD: 4068, p99: 40308, gapMax: 41226, burst: 18.5, normal: 73.5 },
  { label: "100ms/50%", close: 50, pkts: 12801, complete: 100, gapSD: 167, p99: 1266, gapMax: 1722, burst: 0.1, normal: 91.4 },
];

const multiGclData = [
  { label: "10ms (2/6/2)", desc: "3-gate: 2ms open, 6ms close, 2ms open", openPct: 40, pkts: 12801, complete: 100, gapSD: 1730, p99: 6911, gapMax: 7225, burst: 50.9,
    entries: [{g:'O',t:2},{g:'C',t:6},{g:'O',t:2}] },
  { label: "10ms (1/8/1)", desc: "3-gate: 1ms open, 8ms close, 1ms open", openPct: 20, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0,
    entries: [{g:'O',t:1},{g:'C',t:8},{g:'O',t:1}] },
  { label: "20ms (5/5/5/5)", desc: "4-gate: alternating 5ms", openPct: 50, pkts: 12801, complete: 100, gapSD: 1454, p99: 5923, gapMax: 6456, burst: 44.6,
    entries: [{g:'O',t:5},{g:'C',t:5},{g:'O',t:5},{g:'C',t:5}] },
  { label: "100ms (30/20/30/20)", desc: "4-gate: frame split", openPct: 60, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0,
    entries: [{g:'O',t:30},{g:'C',t:20},{g:'O',t:30},{g:'C',t:20}] },
];

const enduranceData = [
  { label: "1ms/50%", dur: 60, pkts: 76801, complete: 100, gapSD: 358, p99: 1408, gapMax: 2312, burst: 5.8, normal: 73.3 },
  { label: "10ms/20%", dur: 60, pkts: 76800, complete: 100, gapSD: 2293, p99: 8920, gapMax: 9736, burst: 73.3, normal: 10.8 },
  { label: "50ms/20%", dur: 60, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, normal: 0 },
  { label: "781\u00b5s/50%", dur: 60, pkts: 76800, complete: 100, gapSD: 196, p99: 1457, gapMax: 2300, burst: 0.9, normal: 90.4 },
  { label: "100ms/70%", dur: 60, pkts: 65661, complete: 100, gapSD: 2875, p99: 1520, gapMax: 31486, burst: 15.9, normal: 75.1 },
];

const boundaryData = [
  { label: "1ms/99%", close: 10, pkts: 12801, complete: 100, gapSD: 152, p99: 1247, gapMax: 1673, burst: 0.1, normal: 92.7 },
  { label: "1ms/98%", close: 20, pkts: 12800, complete: 100, gapSD: 164, p99: 1269, gapMax: 1754, burst: 0.1, normal: 92.5 },
  { label: "1ms/95%", close: 50, pkts: 12800, complete: 100, gapSD: 199, p99: 1309, gapMax: 1796, burst: 0.3, normal: 88.5 },
  { label: "1ms/90%", close: 100, pkts: 12801, complete: 100, gapSD: 217, p99: 1315, gapMax: 1716, burst: 0.2, normal: 86.5 },
  { label: "200ms/80%", close: 40000, pkts: 11231, complete: 100, gapSD: 2672, p99: 1296, gapMax: 41442, burst: 8.0, normal: 83.5 },
  { label: "500ms/50%", close: 250000, pkts: 12801, complete: 100, gapSD: 178, p99: 1280, gapMax: 1783, burst: 0.2, normal: 89.9 },
];

// ── Helper: build result table ──
function buildTable(selId, dataset, columns) {
  const tbl = d3.select('#' + selId);
  const th = tbl.append('thead').append('tr');
  columns.forEach(c => th.append('th').text(c.header));
  const tb = tbl.append('tbody');
  dataset.forEach(d => {
    const tr = tb.append('tr');
    if (d.complete >= 100) tr.classed('baseline', true);
    columns.forEach(c => {
      const td = tr.append('td');
      const val = c.fn(d);
      td.text(val);
      if (c.loss && (d.complete < 100 || d.pkts === 0)) td.classed('loss', true);
    });
  });
}

// Sub-ms table
buildTable('subMsTable', subMsData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Cycle', fn: d => d.cycle + '\u00b5s' },
  { header: 'Open%', fn: d => d.openPct + '%' },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD + '\u00b5s' },
  { header: 'P99', fn: d => d.p99 + '\u00b5s' },
  { header: 'Max Gap', fn: d => d.gapMax + '\u00b5s' },
  { header: 'Burst%', fn: d => d.burst + '%' },
  { header: 'Normal%', fn: d => d.normal + '%' },
]);

// Sub-ms jitter chart
barChart('chartSubMsJitter', subMsData, 'gapSD', 'Gap StdDev (\u00b5s)', v => v.toFixed(0),
  d => d.openPct >= 80 ? '#00e676' : '#00d2ff');

// Buffer table
buildTable('bufferTable', bufferData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Close (ms)', fn: d => d.close + 'ms' },
  { header: 'Packets', fn: d => d.pkts.toLocaleString() },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'PPS', fn: d => d.pps.toFixed(0) },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'Max Gap', fn: d => d.gapMax ? (d.gapMax >= 10000 ? (d.gapMax/1000).toFixed(1)+'ms' : d.gapMax+'\u00b5s') : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// Buffer threshold chart
(function() {
  const svg = d3.select('#chartBufferThreshold');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 80, bottom: 50, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 320 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  // Close time sweep (first 9 entries)
  const sweepData = bufferData.slice(0, 9);
  const x = d3.scaleBand().domain(sweepData.map(d=>d.label)).range([0, w*0.6]).padding(0.2);
  const y = d3.scaleLinear().domain([0, 105]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>y(d)).attr('y2',d=>y(d));

  // Danger zone
  g.append('rect').attr('x', 0).attr('y', y(50)).attr('width', w).attr('height', y(0)-y(50))
    .attr('fill', '#ff5252').attr('opacity', 0.05);
  g.append('text').attr('x', w-5).attr('y', y(25)).attr('text-anchor','end')
    .attr('fill', '#ff5252').attr('font-size', '9px').attr('opacity', 0.5).text('Danger Zone');

  // Bars
  sweepData.forEach(d => {
    g.append('rect')
      .attr('x', x(d.label))
      .attr('y', y(d.complete))
      .attr('width', x.bandwidth())
      .attr('height', h - y(d.complete))
      .attr('fill', d.complete === 0 ? '#ff5252' : d.complete < 100 ? '#ffab40' : '#00e676')
      .attr('rx', 3)
      .attr('opacity', 0.85);

    g.append('text')
      .attr('x', x(d.label) + x.bandwidth()/2)
      .attr('y', d.complete === 0 ? y(5) : y(d.complete) - 5)
      .attr('text-anchor', 'middle')
      .attr('fill', d.complete === 0 ? '#ff5252' : '#c8d6e5')
      .attr('font-size', '10px')
      .text(d.complete === 0 ? '0%' : d.complete + '%');
  });

  // Open% sweep (last 4 entries) on right side
  const sweepData2 = bufferData.slice(9);
  const x2 = d3.scaleBand().domain(sweepData2.map(d=>d.label)).range([w*0.65, w]).padding(0.2);

  sweepData2.forEach(d => {
    g.append('rect')
      .attr('x', x2(d.label))
      .attr('y', y(d.complete))
      .attr('width', x2.bandwidth())
      .attr('height', h - y(d.complete))
      .attr('fill', d.complete === 0 ? '#ff5252' : d.complete < 100 ? '#ffab40' : '#00e676')
      .attr('rx', 3)
      .attr('opacity', 0.85);

    g.append('text')
      .attr('x', x2(d.label) + x2.bandwidth()/2)
      .attr('y', d.complete === 0 ? y(5) : y(d.complete) - 5)
      .attr('text-anchor', 'middle')
      .attr('fill', d.complete === 0 ? '#ff5252' : '#c8d6e5')
      .attr('font-size', '10px')
      .text(d.complete === 0 ? '0%' : d.complete + '%');
  });

  // Labels
  g.append('text').attr('x', w*0.3).attr('y', -10).attr('text-anchor','middle')
    .attr('fill', '#8899aa').attr('font-size', '11px').text('Close Time Sweep (20% open)');
  g.append('text').attr('x', w*0.825).attr('y', -10).attr('text-anchor','middle')
    .attr('fill', '#8899aa').attr('font-size', '11px').text('Open% Sweep (50ms cycle)');

  // Separator line
  g.append('line').attr('x1', w*0.625).attr('x2', w*0.625)
    .attr('y1', 0).attr('y2', h).attr('stroke', '#1e2a42').attr('stroke-dasharray', '5,5');

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x)).selectAll('text').attr('transform','rotate(-35)').style('text-anchor','end');

  const xAxis2 = g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x2)).selectAll('text').attr('transform','rotate(-35)').style('text-anchor','end');

  g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Completeness (%)');
})();

// Frame-aligned table
buildTable('frameAlignedTable', frameAlignedData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Close (ms)', fn: d => d.close + 'ms' },
  { header: 'Packets', fn: d => d.pkts.toLocaleString() },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD + '\u00b5s' },
  { header: 'Max Gap', fn: d => d.gapMax >= 10000 ? (d.gapMax/1000).toFixed(1)+'ms' : d.gapMax+'\u00b5s' },
  { header: 'Burst%', fn: d => d.burst + '%' },
  { header: 'Normal%', fn: d => d.normal + '%' },
]);

// Frame-aligned chart
barChart('chartFrameAligned', frameAlignedData, 'gapSD', 'Gap StdDev (\u00b5s)', v => v.toFixed(0),
  d => d.gapSD > 500 ? '#ffab40' : '#00d2ff');

// Multi-GCL table
buildTable('multiGclTable', multiGclData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Description', fn: d => d.desc },
  { header: 'Open%', fn: d => d.openPct + '%' },
  { header: 'Packets', fn: d => d.pkts.toLocaleString() },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// Multi-GCL Gate Gantt
(function() {
  const svg = d3.select('#chartMultiGcl');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 20, right: 30, bottom: 30, left: 200 };
  const w = bbox.width - margin.left - margin.right;
  const h = 250 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const y = d3.scaleBand().domain(multiGclData.map(d=>d.label)).range([0, h]).padding(0.3);

  multiGclData.forEach(d => {
    const totalMs = d.entries.reduce((s,e) => s + e.t, 0);
    const xScale = d3.scaleLinear().domain([0, totalMs]).range([0, w]);
    let offset = 0;

    d.entries.forEach(e => {
      g.append('rect')
        .attr('x', xScale(offset))
        .attr('y', y(d.label))
        .attr('width', xScale(e.t))
        .attr('height', y.bandwidth())
        .attr('fill', e.g === 'O' ? '#00e676' : '#ff5252')
        .attr('opacity', 0.7)
        .attr('rx', 3);

      g.append('text')
        .attr('x', xScale(offset) + xScale(e.t)/2)
        .attr('y', y(d.label) + y.bandwidth()/2 + 4)
        .attr('text-anchor', 'middle')
        .attr('fill', '#fff')
        .attr('font-size', '10px')
        .text(e.t + 'ms');

      offset += e.t;
    });

    // Status
    const statusColor = d.complete > 0 ? '#00e676' : '#ff5252';
    const statusText = d.complete > 0 ? '100%' : '0%';
    g.append('text')
      .attr('x', w + 10)
      .attr('y', y(d.label) + y.bandwidth()/2 + 4)
      .attr('fill', statusColor)
      .attr('font-size', '12px')
      .attr('font-weight', 'bold')
      .text(statusText);
  });

  g.append('g').attr('class','axis').call(d3.axisLeft(y));

  // Legend
  const leg = g.append('g').attr('transform', `translate(0, ${h+10})`);
  leg.append('rect').attr('x',0).attr('y',0).attr('width',10).attr('height',10).attr('fill','#00e676').attr('opacity',0.7);
  leg.append('text').attr('x',14).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text('Gate Open');
  leg.append('rect').attr('x',100).attr('y',0).attr('width',10).attr('height',10).attr('fill','#ff5252').attr('opacity',0.7);
  leg.append('text').attr('x',114).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text('Gate Close');
})();

// Endurance table
buildTable('enduranceTable', enduranceData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Duration', fn: d => d.dur + 's' },
  { header: 'Packets', fn: d => d.pkts.toLocaleString() },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'P99', fn: d => d.p99 ? d.p99 + '\u00b5s' : '\u2014' },
  { header: 'Max Gap', fn: d => d.gapMax ? (d.gapMax >= 10000 ? (d.gapMax/1000).toFixed(1)+'ms' : d.gapMax+'\u00b5s') : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
  { header: 'Normal%', fn: d => d.normal + '%' },
]);

// Boundary table
buildTable('boundaryTable', boundaryData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Close', fn: d => d.close >= 1000 ? (d.close/1000).toFixed(0)+'ms' : d.close+'\u00b5s' },
  { header: 'Packets', fn: d => d.pkts.toLocaleString() },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD + '\u00b5s' },
  { header: 'P99', fn: d => d.p99 + '\u00b5s' },
  { header: 'Max Gap', fn: d => d.gapMax >= 10000 ? (d.gapMax/1000).toFixed(1)+'ms' : d.gapMax+'\u00b5s' },
  { header: 'Burst%', fn: d => d.burst + '%' },
  { header: 'Normal%', fn: d => d.normal + '%' },
]);

// ── Comprehensive Heatmap ──
(function() {
  // Combine all tests into a close_time vs completeness view
  const allTests = [
    // From original sweep + comprehensive
    { label: "1ms/80%", close_ms: 0.2, complete: 100 },
    { label: "1ms/50%", close_ms: 0.5, complete: 100 },
    { label: "1ms/20%", close_ms: 0.8, complete: 100 },
    { label: "5ms/80%", close_ms: 1, complete: 100 },
    { label: "5ms/50%", close_ms: 2.5, complete: 100 },
    { label: "5ms/20%", close_ms: 4, complete: 100 },
    { label: "10ms/80%", close_ms: 2, complete: 100 },
    { label: "10ms/50%", close_ms: 5, complete: 100 },
    { label: "10ms/20%", close_ms: 8, complete: 100 },
    { label: "50ms/80%", close_ms: 10, complete: 100 },
    { label: "50ms/50%", close_ms: 25, complete: 100 },
    { label: "50ms/20%", close_ms: 40, complete: 51 },
    // New buffer mapping
    { label: "15ms/20%", close_ms: 12, complete: 100 },
    { label: "20ms/20%", close_ms: 16, complete: 100 },
    { label: "25ms/20%", close_ms: 20, complete: 0 },
    { label: "30ms/20%", close_ms: 24, complete: 72 },
    { label: "35ms/20%", close_ms: 28, complete: 0 },
    { label: "40ms/20%", close_ms: 32, complete: 58 },
    { label: "45ms/20%", close_ms: 36, complete: 0 },
    // Frame-aligned
    { label: "100ms/90%", close_ms: 10, complete: 100 },
    { label: "100ms/80%", close_ms: 20, complete: 100 },
    { label: "100ms/70%", close_ms: 30, complete: 100 },
    { label: "100ms/60%", close_ms: 40, complete: 100 },
    { label: "100ms/50%", close_ms: 50, complete: 100 },
    // Boundary
    { label: "200ms/80%", close_ms: 40, complete: 100 },
    { label: "500ms/50%", close_ms: 250, complete: 100 },
  ];

  const svg = d3.select('#chartHeatmap');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 20, right: 30, bottom: 50, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 400 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  // Scatter plot: close_ms vs completeness
  const x = d3.scaleLog().domain([0.1, 300]).range([0, w]);
  const y = d3.scaleLinear().domain([-5, 105]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>y(d)).attr('y2',d=>y(d));

  // Danger threshold line at close=16ms
  g.append('line')
    .attr('x1', x(16)).attr('x2', x(16))
    .attr('y1', 0).attr('y2', h)
    .attr('stroke', '#ff5252').attr('stroke-dasharray', '5,5').attr('opacity', 0.5);
  g.append('text').attr('x', x(16)+5).attr('y', 15)
    .attr('fill', '#ff5252').attr('font-size', '9px').text('16ms threshold');

  // Points
  g.selectAll('circle').data(allTests).enter()
    .append('circle')
    .attr('cx', d => x(Math.max(0.1, d.close_ms)))
    .attr('cy', d => y(d.complete))
    .attr('r', 7)
    .attr('fill', d => d.complete >= 100 ? '#00e676' : d.complete > 0 ? '#ffab40' : '#ff5252')
    .attr('stroke', '#fff')
    .attr('stroke-width', 1)
    .attr('opacity', 0.8);

  // Labels for interesting points
  allTests.filter(d => d.complete < 100 || d.close_ms >= 100).forEach(d => {
    g.append('text')
      .attr('x', x(Math.max(0.1, d.close_ms)) + 10)
      .attr('y', y(d.complete) + 4)
      .attr('fill', '#c8d6e5')
      .attr('font-size', '9px')
      .text(d.label);
  });

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x).tickValues([0.1, 0.5, 1, 2, 5, 10, 20, 50, 100, 250])
      .tickFormat(d => d >= 1 ? d+'ms' : (d*1000)+'\u00b5s'));
  g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('x', w/2).attr('y', h+40).attr('text-anchor','middle')
    .attr('fill','#8899aa').attr('font-size','12px').text('Gate Close Time');
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Completeness (%)');

  // Legend
  const leg = g.append('g').attr('transform', `translate(${w-200}, 0)`);
  [['#00e676','100%'],['#ffab40','Partial'],['#ff5252','0% (Total Loss)']].forEach((d,i) => {
    leg.append('circle').attr('cx',0).attr('cy',i*18).attr('r',5).attr('fill',d[0]);
    leg.append('text').attr('x',10).attr('y',i*18+4).attr('fill','#c8d6e5').attr('font-size','10px').text(d[1]);
  });
})();

// ══════════════════════════════════════════════════════════════
// MULTI-TC TAS DATA (30 tests, 5 categories)
// ══════════════════════════════════════════════════════════════

const tc0SweepData = [
  { label: "TC0=1ms (10%)", tc0_ms: 1, tc0_pct: 10, tc6_ms: 5, tc2_ms: 4, pkts: 12801, complete: 100, gapSD: 2565, p99: 9793, gapMax: 10119, burst: 79.5, normal: 0.0 },
  { label: "TC0=2ms (20%)", tc0_ms: 2, tc0_pct: 20, tc6_ms: 4, tc2_ms: 4, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, normal: 0 },
  { label: "TC0=3ms (30%)", tc0_ms: 3, tc0_pct: 30, tc6_ms: 4, tc2_ms: 3, pkts: 12801, complete: 100, gapSD: 2023, p99: 7940, gapMax: 8350, burst: 63.9, normal: 20.7 },
  { label: "TC0=4ms (40%)", tc0_ms: 4, tc0_pct: 40, tc6_ms: 3, tc2_ms: 3, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, normal: 0 },
  { label: "TC0=5ms (50%)", tc0_ms: 5, tc0_pct: 50, tc6_ms: 3, tc2_ms: 2, pkts: 12801, complete: 100, gapSD: 1450, p99: 5882, gapMax: 6246, burst: 45.0, normal: 41.2 },
  { label: "TC0=6ms (60%)", tc0_ms: 6, tc0_pct: 60, tc6_ms: 2, tc2_ms: 2, pkts: 12801, complete: 100, gapSD: 175, p99: 1259, gapMax: 1750, burst: 0.2, normal: 90.8 },
  { label: "TC0=7ms (70%)", tc0_ms: 7, tc0_pct: 70, tc6_ms: 2, tc2_ms: 1, pkts: 12801, complete: 100, gapSD: 892, p99: 3888, gapMax: 4370, burst: 22.8, normal: 57.9 },
  { label: "TC0=8ms (80%)", tc0_ms: 8, tc0_pct: 80, tc6_ms: 1, tc2_ms: 1, pkts: 12801, complete: 100, gapSD: 159, p99: 1263, gapMax: 1789, burst: 0.1, normal: 92.2 },
];

const fragData = [
  { label: "1\u00d74ms (contiguous)", windows: 1, winSize: 4.0, tc0_pct: 40, pkts: 12801, complete: 100, gapSD: 1749, p99: 7043, gapMax: 7762, burst: 51.2, normal: 28.2,
    entries: [{g:'TC0',t:4,c:'#00e676'},{g:'TC6',t:6,c:'#ffd740'}] },
  { label: "2\u00d72ms (split)", windows: 2, winSize: 2.0, tc0_pct: 40, pkts: 12801, complete: 100, gapSD: 181, p99: 1275, gapMax: 1794, burst: 0.2, normal: 89.9,
    entries: [{g:'TC0',t:2,c:'#00e676'},{g:'TC6',t:3,c:'#ffd740'},{g:'TC0',t:2,c:'#00e676'},{g:'TC2',t:3,c:'#00d2ff'}] },
  { label: "3\u00d71.3ms (fragmented)", windows: 3, winSize: 1.33, tc0_pct: 40, pkts: 12801, complete: 100, gapSD: 1032, p99: 2961, gapMax: 3305, burst: 45.5, normal: 18.8,
    entries: [{g:'TC0',t:1.33,c:'#00e676'},{g:'TC6',t:2,c:'#ffd740'},{g:'TC0',t:1.33,c:'#00e676'},{g:'TC2',t:2,c:'#00d2ff'},{g:'TC0',t:1.34,c:'#00e676'},{g:'TC6',t:2,c:'#ffd740'}] },
  { label: "5\u00d71ms (high freq)", windows: 5, winSize: 1.0, tc0_pct: 40, pkts: 12801, complete: 100, gapSD: 162, p99: 1263, gapMax: 1801, burst: 0.2, normal: 91.7,
    entries: [{g:'TC0',t:1,c:'#00e676'},{g:'TC6',t:1,c:'#ffd740'},{g:'TC0',t:1,c:'#00e676'},{g:'TC6',t:1,c:'#ffd740'},{g:'TC0',t:1,c:'#00e676'},{g:'TC6',t:1,c:'#ffd740'},{g:'TC0',t:1,c:'#00e676'},{g:'TC6',t:3,c:'#ffd740'}] },
  { label: "4\u00d70.5ms (ultra-fast)", windows: 4, winSize: 0.5, tc0_pct: 20, pkts: 12800, complete: 100, gapSD: 1844, p99: 7120, gapMax: 7811, burst: 56.8, normal: 22.8,
    entries: [{g:'TC0',t:0.5,c:'#00e676'},{g:'TC6',t:0.5,c:'#ffd740'},{g:'TC0',t:0.5,c:'#00e676'},{g:'TC6',t:0.5,c:'#ffd740'},{g:'TC0',t:0.5,c:'#00e676'},{g:'TC6',t:0.5,c:'#ffd740'},{g:'TC0',t:0.5,c:'#00e676'},{g:'TC6',t:6.5,c:'#ffd740'}] },
  { label: "1\u00d72ms (half baseline)", windows: 1, winSize: 2.0, tc0_pct: 20, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, normal: 0,
    entries: [{g:'TC0',t:2,c:'#00e676'},{g:'TC6',t:8,c:'#ffd740'}] },
];

const cycleScaleData = [
  { label: "2ms", cycle_ms: 2, tc0_ms: 0.8, tc6_ms: 0.6, tc2_ms: 0.4, guard_ms: 0.2, pkts: 12800, complete: 100, gapSD: 685, p99: 2035, gapMax: 2769, burst: 24.6, normal: 18.4 },
  { label: "5ms", cycle_ms: 5, tc0_ms: 2, tc6_ms: 1.5, tc2_ms: 1, guard_ms: 0.5, pkts: 12801, complete: 100, gapSD: 1039, p99: 3452, gapMax: 4069, burst: 34.1, normal: 32.2 },
  { label: "10ms", cycle_ms: 10, tc0_ms: 4, tc6_ms: 3, tc2_ms: 2, guard_ms: 1, pkts: 12801, complete: 100, gapSD: 1452, p99: 5907, gapMax: 6341, burst: 43.7, normal: 40.6 },
  { label: "20ms", cycle_ms: 20, tc0_ms: 8, tc6_ms: 6, tc2_ms: 4, guard_ms: 2, pkts: 12800, complete: 100, gapSD: 160, p99: 1254, gapMax: 1732, burst: 0.1, normal: 92.3 },
  { label: "50ms", cycle_ms: 50, tc0_ms: 20, tc6_ms: 15, tc2_ms: 10, guard_ms: 5, pkts: 10347, complete: 100, gapSD: 3515, p99: 25822, gapMax: 26523, burst: 33.7, normal: 54.9 },
  { label: "100ms", cycle_ms: 100, tc0_ms: 40, tc6_ms: 30, tc2_ms: 20, guard_ms: 10, pkts: 12801, complete: 100, gapSD: 175, p99: 1268, gapMax: 1923, burst: 0.3, normal: 90.6 },
];

const roiiData = [
  { label: "ROII-Standard", tc0: 4.0, tc6: 2.5, tc5: 1.5, tc2: 1.0, guard: 1.0, effTc0: 50, pkts: 12801, complete: 100, gapSD: 1451, p99: 5890, gapMax: 7001, burst: 44.6, normal: 39.9 },
  { label: "LiDAR-Heavy", tc0: 6.0, tc6: 1.5, tc5: 1.0, tc2: 0.5, guard: 1.0, effTc0: 70, pkts: 12801, complete: 100, gapSD: 186, p99: 1292, gapMax: 2103, burst: 0.3, normal: 89.0 },
  { label: "Radar-Heavy", tc0: 2.0, tc6: 5.0, tc5: 1.0, tc2: 1.0, guard: 1.0, effTc0: 30, pkts: 12801, complete: 100, gapSD: 2005, p99: 7865, gapMax: 8271, burst: 63.1, normal: 21.5 },
  { label: "Camera-Heavy", tc0: 2.0, tc6: 1.0, tc5: 5.0, tc2: 1.0, guard: 1.0, effTc0: 30, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, normal: 0 },
  { label: "Equal-Share", tc0: 2.0, tc6: 2.0, tc5: 2.0, tc2: 2.0, guard: 2.0, effTc0: 40, pkts: 12801, complete: 100, gapSD: 1739, p99: 6924, gapMax: 7350, burst: 52.4, normal: 30.4 },
];

const guardData = [
  { label: "Guard=0ms", guard_ms: 0, tc6_ms: 6, effTc0: 4, effPct: 40, pkts: 12800, complete: 100, gapSD: 159, p99: 1255, gapMax: 1748, burst: 0.2, normal: 92.3 },
  { label: "Guard=1ms", guard_ms: 1, tc6_ms: 5, effTc0: 5, effPct: 50, pkts: 12801, complete: 100, gapSD: 1452, p99: 5894, gapMax: 6699, burst: 44.8, normal: 41.3 },
  { label: "Guard=2ms", guard_ms: 2, tc6_ms: 4, effTc0: 6, effPct: 60, pkts: 0, complete: 0, gapSD: 0, p99: 0, gapMax: 0, burst: 0, normal: 0 },
  { label: "Guard=3ms", guard_ms: 3, tc6_ms: 3, effTc0: 7, effPct: 70, pkts: 12801, complete: 100, gapSD: 882, p99: 3865, gapMax: 4220, burst: 22.3, normal: 58.6 },
  { label: "Guard=6ms", guard_ms: 6, tc6_ms: 0, effTc0: 10, effPct: 100, pkts: 12800, complete: 100, gapSD: 172, p99: 1268, gapMax: 2002, burst: 0.2, normal: 90.9 },
];

// ── Cat A: TC0 Allocation Sweep ──

buildTable('tc0SweepTable', tc0SweepData, [
  { header: 'Config', fn: d => d.label },
  { header: 'TC0', fn: d => d.tc0_ms + 'ms' },
  { header: 'TC6', fn: d => d.tc6_ms + 'ms' },
  { header: 'TC2', fn: d => d.tc2_ms + 'ms' },
  { header: 'TC0%', fn: d => d.tc0_pct + '%' },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'P99', fn: d => d.p99 ? d.p99 + '\u00b5s' : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// TC0 Sweep dual chart: Completeness + GapSD
(function() {
  const svg = d3.select('#chartTc0Sweep');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 80, bottom: 50, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 350 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  // Gantt-style per-TC visualization at top
  const ganttH = 50;
  const mainH = h - ganttH - 20;

  // Draw one sample Gantt for 10ms cycle
  const gx = d3.scaleLinear().domain([0, 10]).range([0, w]);
  const tcColors = {'TC0': '#00e676', 'TC6': '#ffd740', 'TC2': '#00d2ff'};

  tc0SweepData.forEach((d, i) => {
    if (i > 3) return; // Show first 4 for space
    const yPos = i * 12;
    let offset = 0;
    [{t: d.tc0_ms, tc:'TC0'}, {t: d.tc6_ms, tc:'TC6'}, {t: d.tc2_ms, tc:'TC2'}].forEach(e => {
      g.append('rect').attr('x', gx(offset)).attr('y', yPos)
        .attr('width', gx(e.t)).attr('height', 10)
        .attr('fill', tcColors[e.tc]).attr('opacity', 0.6).attr('rx', 2);
      offset += e.t;
    });
    g.append('text').attr('x', -5).attr('y', yPos + 8)
      .attr('text-anchor', 'end').attr('fill', '#8899aa').attr('font-size', '8px')
      .text(d.tc0_pct + '%');
  });

  // Main bar chart below
  const gy = ganttH + 10;
  const x = d3.scaleBand().domain(tc0SweepData.map(d => d.label)).range([0, w]).padding(0.2);
  const ySD = d3.scaleLinear().domain([0, 3000]).range([mainH, 0]);

  g.selectAll('.grid-line-tc0').data(ySD.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w)
    .attr('y1',d=>ySD(d)+gy).attr('y2',d=>ySD(d)+gy);

  tc0SweepData.forEach(d => {
    const barColor = d.complete === 0 ? '#ff5252' : d.gapSD < 300 ? '#00e676' : d.gapSD < 1500 ? '#ffab40' : '#ff5252';
    const val = d.complete === 0 ? 3000 : d.gapSD;

    g.append('rect')
      .attr('x', x(d.label)).attr('y', ySD(val) + gy)
      .attr('width', x.bandwidth()).attr('height', mainH - ySD(val))
      .attr('fill', barColor).attr('rx', 3).attr('opacity', d.complete === 0 ? 0.4 : 0.85);

    g.append('text')
      .attr('x', x(d.label) + x.bandwidth()/2)
      .attr('y', d.complete === 0 ? ySD(1500) + gy : ySD(val) + gy - 5)
      .attr('text-anchor', 'middle').attr('fill', d.complete === 0 ? '#ff5252' : '#c8d6e5')
      .attr('font-size', '10px')
      .text(d.complete === 0 ? 'LOSS' : d.gapSD + '\u00b5s');
  });

  g.append('g').attr('class','axis').attr('transform',`translate(0,${mainH+gy})`)
    .call(d3.axisBottom(x)).selectAll('text').attr('transform','rotate(-25)').style('text-anchor','end');
  g.append('g').attr('class','axis').attr('transform',`translate(0,${gy})`)
    .call(d3.axisLeft(ySD).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-(mainH/2+gy)).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Gap StdDev (\u00b5s)');
})();


// ── Cat B: Fragmentation Gantt ──

(function() {
  const svg = d3.select('#chartFragGantt');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 20, right: 80, bottom: 30, left: 200 };
  const w = bbox.width - margin.left - margin.right;
  const h = 300 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const y = d3.scaleBand().domain(fragData.map(d=>d.label)).range([0, h]).padding(0.25);

  fragData.forEach(d => {
    const totalMs = d.entries.reduce((s,e) => s + e.t, 0);
    const xScale = d3.scaleLinear().domain([0, totalMs]).range([0, w]);
    let offset = 0;

    d.entries.forEach(e => {
      g.append('rect')
        .attr('x', xScale(offset)).attr('y', y(d.label))
        .attr('width', Math.max(1, xScale(e.t))).attr('height', y.bandwidth())
        .attr('fill', e.c).attr('opacity', 0.7).attr('rx', 2);

      if (xScale(e.t) > 25) {
        g.append('text')
          .attr('x', xScale(offset) + xScale(e.t)/2)
          .attr('y', y(d.label) + y.bandwidth()/2 + 4)
          .attr('text-anchor', 'middle').attr('fill', '#000').attr('font-size', '9px').attr('font-weight','bold')
          .text(e.g + ' ' + e.t + 'ms');
      }
      offset += e.t;
    });

    // Status badge
    const statusColor = d.complete > 0 ? '#00e676' : '#ff5252';
    g.append('text').attr('x', w + 10).attr('y', y(d.label) + y.bandwidth()/2 + 4)
      .attr('fill', statusColor).attr('font-size', '11px').attr('font-weight','bold')
      .text(d.complete > 0 ? d.gapSD + '\u00b5s' : 'LOSS');
  });

  g.append('g').attr('class','axis').call(d3.axisLeft(y));

  // Legend
  const leg = g.append('g').attr('transform', `translate(0, ${h+5})`);
  [{c:'#00e676',l:'TC0(LiDAR)'},{c:'#ffd740',l:'TC6(Radar)'},{c:'#00d2ff',l:'TC2(Control)'}].forEach((d,i) => {
    leg.append('rect').attr('x',i*120).attr('y',0).attr('width',10).attr('height',10).attr('fill',d.c).attr('opacity',0.7);
    leg.append('text').attr('x',i*120+14).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text(d.l);
  });
})();

// Fragmentation table
buildTable('fragTable', fragData, [
  { header: 'Config', fn: d => d.label },
  { header: 'Windows', fn: d => d.windows },
  { header: 'TC0 Total', fn: d => (d.windows * d.winSize).toFixed(1) + 'ms' },
  { header: 'TC0%', fn: d => d.tc0_pct + '%' },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// Fragmentation comparison chart (GapSD + Burst)
(function() {
  const svg = d3.select('#chartFragCompare');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 80, bottom: 60, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 300 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const validFrag = fragData.filter(d => d.complete > 0);
  const x = d3.scaleBand().domain(validFrag.map(d=>d.label)).range([0, w]).padding(0.15);
  const x1 = d3.scaleBand().domain(['gapSD','burst']).range([0, x.bandwidth()]).padding(0.1);
  const ySD = d3.scaleLinear().domain([0, 2000]).range([h, 0]);
  const yB = d3.scaleLinear().domain([0, 70]).range([h, 0]);

  g.selectAll('.grid-line').data(ySD.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>ySD(d)).attr('y2',d=>ySD(d));

  validFrag.forEach(d => {
    // GapSD bar
    g.append('rect')
      .attr('x', x(d.label) + x1('gapSD')).attr('y', ySD(d.gapSD))
      .attr('width', x1.bandwidth()).attr('height', h - ySD(d.gapSD))
      .attr('fill', '#00d2ff').attr('opacity', 0.8).attr('rx', 2);
    g.append('text')
      .attr('x', x(d.label) + x1('gapSD') + x1.bandwidth()/2)
      .attr('y', ySD(d.gapSD) - 4)
      .attr('text-anchor','middle').attr('fill','#c8d6e5').attr('font-size','9px')
      .text(d.gapSD);

    // Burst bar
    const burstH = d.burst / 70 * h;
    g.append('rect')
      .attr('x', x(d.label) + x1('burst')).attr('y', h - burstH)
      .attr('width', x1.bandwidth()).attr('height', burstH)
      .attr('fill', '#ff5252').attr('opacity', 0.7).attr('rx', 2);
    g.append('text')
      .attr('x', x(d.label) + x1('burst') + x1.bandwidth()/2)
      .attr('y', h - burstH - 4)
      .attr('text-anchor','middle').attr('fill','#c8d6e5').attr('font-size','9px')
      .text(d.burst + '%');
  });

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x)).selectAll('text').attr('transform','rotate(-25)').style('text-anchor','end');
  g.append('g').attr('class','axis').call(d3.axisLeft(ySD).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Gap StdDev (\u00b5s)');

  // Legend
  const leg = g.append('g').attr('transform', `translate(${w-200}, -15)`);
  leg.append('rect').attr('x',0).attr('y',0).attr('width',10).attr('height',10).attr('fill','#00d2ff').attr('opacity',0.8);
  leg.append('text').attr('x',14).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text('Gap StdDev');
  leg.append('rect').attr('x',100).attr('y',0).attr('width',10).attr('height',10).attr('fill','#ff5252').attr('opacity',0.7);
  leg.append('text').attr('x',114).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text('Burst %');
})();


// ── Cat C: Cycle Scaling ──

buildTable('cycleScaleTable', cycleScaleData, [
  { header: 'Cycle', fn: d => d.cycle_ms + 'ms' },
  { header: 'TC0', fn: d => d.tc0_ms + 'ms' },
  { header: 'TC6', fn: d => d.tc6_ms + 'ms' },
  { header: 'TC2', fn: d => d.tc2_ms + 'ms' },
  { header: 'Guard', fn: d => d.guard_ms + 'ms' },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD + '\u00b5s' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// Cycle scaling chart
(function() {
  const svg = d3.select('#chartCycleScale');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 30, bottom: 50, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 300 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const x = d3.scaleBand().domain(cycleScaleData.map(d=>d.label)).range([0, w]).padding(0.2);
  const y = d3.scaleLinear().domain([0, 4000]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>y(d)).attr('y2',d=>y(d));

  // Stacked bars: TC0 time (green) + other TC time (gray)
  cycleScaleData.forEach(d => {
    const barColor = d.gapSD < 300 ? '#00e676' : d.gapSD < 1500 ? '#ffab40' : '#ff5252';
    g.append('rect')
      .attr('x', x(d.label)).attr('y', y(d.gapSD))
      .attr('width', x.bandwidth()).attr('height', h - y(d.gapSD))
      .attr('fill', barColor).attr('rx', 3).attr('opacity', 0.85);

    g.append('text')
      .attr('x', x(d.label) + x.bandwidth()/2)
      .attr('y', y(d.gapSD) - 5)
      .attr('text-anchor', 'middle').attr('fill', '#c8d6e5').attr('font-size', '10px')
      .text(d.gapSD);

    // TC0 time label under bar
    g.append('text')
      .attr('x', x(d.label) + x.bandwidth()/2)
      .attr('y', h + 35)
      .attr('text-anchor', 'middle').attr('fill', '#00e676').attr('font-size', '9px')
      .text('TC0=' + d.tc0_ms + 'ms');
  });

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x));
  g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Gap StdDev (\u00b5s)');

  // Title
  g.append('text').attr('x', w/2).attr('y', -10)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','11px')
    .text('ROII Ratio Fixed: TC0=40%, TC6=30%, TC2=20%, Guard=10%');
})();


// ── Cat D: ROII Profiles ──

buildTable('roiiTable', roiiData, [
  { header: 'Profile', fn: d => d.label },
  { header: 'TC0', fn: d => d.tc0 + 'ms' },
  { header: 'TC6', fn: d => d.tc6 + 'ms' },
  { header: 'TC5', fn: d => d.tc5 + 'ms' },
  { header: 'TC2', fn: d => d.tc2 + 'ms' },
  { header: 'Guard', fn: d => d.guard + 'ms' },
  { header: 'Eff TC0%', fn: d => d.effTc0 + '%' },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// ROII Gantt
(function() {
  const svg = d3.select('#chartRoiiGantt');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 20, right: 80, bottom: 30, left: 160 };
  const w = bbox.width - margin.left - margin.right;
  const h = 300 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const y = d3.scaleBand().domain(roiiData.map(d=>d.label)).range([0, h]).padding(0.25);
  const xScale = d3.scaleLinear().domain([0, 10]).range([0, w]);
  const tcColors = {'TC0': '#00e676', 'TC6': '#ffd740', 'TC5': '#7c5cfc', 'TC2': '#00d2ff', 'Guard': '#666'};

  roiiData.forEach(d => {
    let offset = 0;
    [{tc:'TC0',t:d.tc0},{tc:'TC6',t:d.tc6},{tc:'TC5',t:d.tc5},{tc:'TC2',t:d.tc2},{tc:'Guard',t:d.guard}].forEach(e => {
      g.append('rect')
        .attr('x', xScale(offset)).attr('y', y(d.label))
        .attr('width', xScale(e.t)).attr('height', y.bandwidth())
        .attr('fill', tcColors[e.tc]).attr('opacity', 0.7).attr('rx', 2);

      if (xScale(e.t) > 30) {
        g.append('text')
          .attr('x', xScale(offset) + xScale(e.t)/2)
          .attr('y', y(d.label) + y.bandwidth()/2 + 4)
          .attr('text-anchor','middle').attr('fill','#000').attr('font-size','9px').attr('font-weight','bold')
          .text(e.tc + ' ' + e.t);
      }
      offset += e.t;
    });

    // Status
    const sc = d.complete > 0 ? '#00e676' : '#ff5252';
    g.append('text').attr('x', w + 10).attr('y', y(d.label) + y.bandwidth()/2 + 4)
      .attr('fill', sc).attr('font-size','11px').attr('font-weight','bold')
      .text(d.complete > 0 ? d.complete + '%' : 'LOSS');
  });

  g.append('g').attr('class','axis').call(d3.axisLeft(y));

  // Time axis
  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(xScale).ticks(10).tickFormat(d => d + 'ms'));

  // Legend
  const leg = g.append('g').attr('transform', `translate(0, ${h+5})`);
  Object.entries(tcColors).forEach(([tc,c], i) => {
    leg.append('rect').attr('x',i*90).attr('y',0).attr('width',10).attr('height',10).attr('fill',c).attr('opacity',0.7);
    leg.append('text').attr('x',i*90+14).attr('y',9).attr('fill','#c8d6e5').attr('font-size','10px').text(tc);
  });
})();

// ROII comparison chart
barChart('chartRoiiCompare', roiiData.filter(d=>d.complete>0), 'gapSD', 'Gap StdDev (\u00b5s)',
  v => v.toFixed(0), d => d.gapSD < 300 ? '#00e676' : d.gapSD < 1500 ? '#ffab40' : '#ff5252');


// ── Cat E: Guard Band ──

buildTable('guardTable', guardData, [
  { header: 'Config', fn: d => d.label },
  { header: 'TC0', fn: d => '4ms' },
  { header: 'Guard', fn: d => d.guard_ms + 'ms' },
  { header: 'TC6', fn: d => d.tc6_ms + 'ms' },
  { header: 'Eff TC0', fn: d => d.effTc0 + 'ms' },
  { header: 'Eff TC0%', fn: d => d.effPct + '%' },
  { header: 'Cmpl%', fn: d => d.complete + '%', loss: true },
  { header: 'Gap SD', fn: d => d.gapSD ? d.gapSD + '\u00b5s' : '\u2014' },
  { header: 'Burst%', fn: d => d.burst + '%' },
]);

// Guard band chart
(function() {
  const svg = d3.select('#chartGuard');
  const bbox = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 30, bottom: 50, left: 70 };
  const w = bbox.width - margin.left - margin.right;
  const h = 300 - margin.top - margin.bottom;
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  const x = d3.scaleBand().domain(guardData.map(d=>d.label)).range([0, w]).padding(0.2);
  const y = d3.scaleLinear().domain([0, 2000]).range([h, 0]);

  g.selectAll('.grid-line').data(y.ticks(5)).enter()
    .append('line').attr('class','grid-line').attr('x1',0).attr('x2',w).attr('y1',d=>y(d)).attr('y2',d=>y(d));

  guardData.forEach(d => {
    const barColor = d.complete === 0 ? '#ff5252' : d.gapSD < 300 ? '#00e676' : d.gapSD < 1000 ? '#ffab40' : '#ff5252';
    const val = d.complete === 0 ? 2000 : d.gapSD;

    g.append('rect')
      .attr('x', x(d.label)).attr('y', y(val))
      .attr('width', x.bandwidth()).attr('height', h - y(val))
      .attr('fill', barColor).attr('rx', 3).attr('opacity', d.complete === 0 ? 0.4 : 0.85);

    g.append('text')
      .attr('x', x(d.label) + x.bandwidth()/2)
      .attr('y', d.complete === 0 ? y(1000) : y(val) - 5)
      .attr('text-anchor','middle').attr('fill', d.complete === 0 ? '#ff5252' : '#c8d6e5')
      .attr('font-size','10px')
      .text(d.complete === 0 ? 'LOSS' : d.gapSD + '\u00b5s');

    // Effective TC0 label
    g.append('text')
      .attr('x', x(d.label) + x.bandwidth()/2)
      .attr('y', h + 35)
      .attr('text-anchor','middle').attr('fill','#00e676').attr('font-size','9px')
      .text('eff=' + d.effTc0 + 'ms');
  });

  g.append('g').attr('class','axis').attr('transform',`translate(0,${h})`)
    .call(d3.axisBottom(x));
  g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(5));
  g.append('text').attr('transform','rotate(-90)').attr('x',-h/2).attr('y',-55)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','12px').text('Gap StdDev (\u00b5s)');

  g.append('text').attr('x', w/2).attr('y', -10)
    .attr('text-anchor','middle').attr('fill','#8899aa').attr('font-size','11px')
    .text('TC0=4ms fixed + Guard(0xFF) varies');
})();

</script>
</body>
</html>
